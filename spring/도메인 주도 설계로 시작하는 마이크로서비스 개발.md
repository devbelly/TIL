 <p align="center">
	<img src="https://github.com/devbelly/TIL/assets/67682840/420a6940-d457-4573-8ccd-f421463d4e09">
</p>

# 1장. 아마존 비즈니스 민첩성의 비밀

## 1.1 성공한 인터넷 기업들과 비즈니스 민첩성

- 아마존은 0.66초마다 1번의 배포가 이루어진다
- 클라우드 인프라의 등장으로 빠른 배포가 가능해졌다.
	- 클라우드 인프라는 레고처럼 여러 장비들이 논리적으로 하나의 장비로 관리된다.
- 애플리케이션 구조도 클라우드 인프라와 같은 구조를 띤다면 민첩한 배포가 가능해진다
- 쇼핑몰 예시
	- 일주일간 타임 세일을 할 예정
	- 많아질 트래픽에 대비하는 두가지 방법, Scale-up과 Scale-out이 있다.
	- 하지만 전체 서비스에 대해서 Scale-out 하는 대신 타임 세일을 담당하는 모듈만 Scale-out하면 더욱 효율적
	
## 1.2 마이크로서비스란 무엇인가?

### 1.2.1 모노리스와 마이크로서비스

**모노리스**
- 하나의 단위로 개발되는 일체형 애플리케이션
- 작은 변경에도 애플리케이션 전체를 배포해야한다.
- 확장이 필요한 경우 특정 기능만 확장할 수 없고 애플리케이션 전체를 확장해야한다.
- 확장된 상태에서 변경은 단점이 더욱 드러난다.
	- 변경이 발생하면 모든 모노리스 시스템을 재배포해야한다.
	- 애플리케이션이 병렬로 확장되어 트래픽에는 대응할 수 있지만 데이터베이스는 하나이므로 대처할 수 있게 scale-up 해야한다.

**마이크로서비스**
- 서버 측이 여러 개의 조각으로 구성되어 별개의 인스턴스에 로딩된다.
- 여러 서비스가 모여 비즈니스 애플리케이션을 구성한다.
- 특정 서비스의 확장이 필요하면 전체 애플리케이션을 확장할 필요 없이 특정 서비스만 확장하면 된다.

### 1.2.2 SOA 와 마이크로서비스

공통점
- 단위 컴포넌트나 서비스를 구성해서 시스템을 만드는 구조는 마이크로서비스와 유사

마이크로서비스
- 그림
	<img width="650" alt="image" src="https://github.com/devbelly/TIL/assets/67682840/1ac60e66-6b1d-4b4c-8dc7-1d9d6f7bc9fb">
- 각 서비스와 데이터베이스는 다른 서비스와 데이터베이스와 분리되어있고 API를 통해 느슨하게 결합되어있다.
- 독립적인 확장이 가능하며 하나의 서비스만 독립적으로 배포가 가능하다.
- 연계된 서비스에 영향을 미치지 않는다면 자유롭게 언어 선택 및 데이터베이스를 선택할 수 있다.
- 특정 서비스를 구축하는데 자유롭게 언어 및 데이터베이스를 선택할 수 있는 것을 `폴리글랏(Polyglot)` 하다라고 표현한다.
- 폴리글랏 저장소 특성을 통해 CBD/SOA가 추구했지만 미흡했던 모듈화를 MSA에서 실현했다.

차이점
- CBD/SOA에서는 애플리케이션을 모듈별로 분리했으나 데이터베이스의 분리까지 이루어지지 못했다.
	- 데이터의 강한 결합으로 애플리케이션을 독립적으로 사용하기 어려웠다.
- MSA는 아래 두가지를 통해 강한 모듈화를 이루었다.
	- 하나의 서비스에서 다른 데이터베이스를 직접 사용할 수 없고 API를 통해서만 가능하다.
	- 각 서비스들은 REST API와 같은 표준을 통해 상호 통신한다.

## 1.3 마이크로서비스를 위한 조건은 무엇인가?


### 1.3.1 조직의 변화 : 업무 기능 중심 팀
- 예전 조직구조는 역할 또는 기술별로 조직이 구분되어있다.
- 하나의 애플리케이션을 만드는 데 여러 팀이 협력해야한다.
	- 팀 간 소통에 COST가 발생
- 업무 기능을 중심으로 한 팀은 역할, 기술별로 팀을 만드는 것이 아니라 다양한 기술군 사람들이 모여 하나의 팀을 이룬다.

	<img width="439" alt="image" src="https://github.com/devbelly/TIL/assets/67682840/5616e107-10fd-4c9d-8b85-54050138095a">

### 1.3.2 관리체계의 변화
- 위 처럼 다기능 팀으로 구성되면 필요한 자원과 인력이 하나의 팀에 소속되므로 다른 팀과 소통할 일이 적다.
- 각 팀은 회사의 규칙에 속하지 않고 자신들만의 언어나 데이터베이스를 선택할 수 있다.
	- 이를 폴리글랏 프로그래밍, 폴리글랏 저장소라고 한다.

### 1.3.3 개발 생명주기의 변화: 프로젝트가 아닌 제품 중심으로
- 기존 방식은 기능 개발과 운영을 분리했다.
- 하지만 마이크로서비스는 기능 개발에만 멈추는 프로젝트 단위가 아닌 비즈니스 서비스를 제공하는 제품 중심으로 개발한다.
	- 즉 개발과 운영을 함께 진행

### 1.3.4 개발환경의 변화 : 인프라 자동화

- 모놀리릭 방식처럼 한 번만 배포한다면 수동배포도 그렇게 나쁜 옵션이 아닐 수 있다.
- 마이크로서비스 처럼 여러개로 쪼개진 상태에서의 수동배포는 좋지 못하다
- 인프라를 코드로 관리하는 기술이 중요해졌다.

### 1.3.5 저장소의 변화 : 통합 저장소가 아닌 분권 데이터 관리

모놀리틱 저장소의 방식
- 스토리지 비용 및 네트워크 속도에 따른 성능 문제로 하나의 저장소에 모두 저장했다.
- 지금은 스토리지 비용이 감소하고 네트워크 대역폭도 넓어져서 하나의 저장소에 모두 저장할 필요는 없다.

마이크로서비스 저장소의 방식
- 폴리글랏 저장소 방식을 선택한다.
- 각 저장소가 서비스 별로 분리되어있고 다른 서비스의 저장소를 직접 호출할 수 없다. API를 통해서 가능

데이터의 중복 저장 및 문제점
- 이러한 구조에서 비즈니스 처리를 위해 데이터를 중복 저장 하거나 복제하는 일이 발생한다.
- 여러 데이터베이스에 데이터가 중복 저장되면 ***일관성***문제가 발생

일관성 문제의 해결
- 첫 번째 해결책은 2단계 커밋
	- 각 서비스가 하나의 트랜잭션으로 묶이게 되면 서비스의 독립성이 침해된다.
	- NoSQL은 2단계 커밋을 지원하지 않는다.
- 두 번째 해결책. 비동기 이벤트 처리를 통한 협업을 강조한다
	- 이를 결과적 일관성이라고 한다.
		- 두 서비스의 트랜잭션을 따로 수행하여  데이터의 일관성이 일치하지 않는  경우도 존재
		- 하지만 마지막에는 일치하게 된다는 개념

### 1.3.6 위기 대응 방식의 변화 : 실패를 고려한 설계

- 항상 실패를 염두한 아키텍쳐 설계를 해야한다.
- 서킷브레이커 패턴을 적용할 수 있다.
	- 회로 차단기처럼 서비스를 모니터링하고 있다가 장애를 감지하면 연관되는 서비스를 차단후 적절히 대응
	- 넷플릭스 카오스몽키. 일부러 장애를 만들어 장애에 제대로 대응하는지 확인

# 2장. MSA의 이해

## 2.1 리액티브 선언 : 현대 애플리케이션이 갖춰야할 속성들

- MSA는 클라우드 인프라를 활용해서 구조화 하는것
- 클라우드 인프라를 고려했을 때 가장 신경 써야하는 것은 리액티브 선언문에 잘 드러나있다.
	- 반응성 : 사용자 요청에 빠르게 응답해야한다.
	- 탄력성 : 장애가 발생하더라도 시스템 전체에 퍼지지 않고 복구가 가능해야한다.
	- 유연성 : 트래픽이 증가하면 그에 맞춰 서버가 증감될 수 있어야 한다.
	- 메세지기반 : 비동기 메세지 전달을 통해 위치 투명성, 느슨한 결합, 논블로킹 통신하는 것을 의미

> [!faq]- 위치투명성?
> - MSA에서 서비스가 로컬 머신에 존재하는지 원격 머신에 존재하는지 여부에 의존하지 않는 것을 의미한다.

- 여러 리액티브 시스템이 갖춰야할 필수 요건은 ==아키텍쳐 유연성==
	- 변화와 확장에 유연하게 대처할 수 있게 한다.
	- 메세징 서비스가 각 컴포넌트의 느슨한 결합을 하게 해주는 핵심 요소

## 2.4 MSA 구성요소 및 패턴

### 2.4.1 인프라 구성요소

- 인프라
	- 베어메탈 장비를 구매후  구축 vs 가상화 인프라 사용
	- MSA는 어디서 실행되는지에 구애받지 않지만 유연성을 위해 가상화 인프라를 사용하는 것을 권장

- VM과 컨테이너
	- 가상화된 인프라를 선택했다면 VM과 컨테이너 중에 선택해야한다.
	- 가상 머신(VM)
		- 하이퍼바이저 소프트웨어를 사용하여 하나의 머신에 여러 운영체제를 사용
		- 게스트 OS를 위한 오버헤드가 발생. 
	- 컨테이너
		- 컨테이너 엔진을 통해 가상의 격리된 공간을 생성
		- 이점
			- 이식성
			- 신속성
			- 재사용성
		- 위 이점은 MSA와 잘 어울린다

- 컨테이너 오케스트레이션
	- 쿠버네티스가 주로 사용된다.


### 2.4.2 마이크로서비스 운영과 관리를 위한 플랫폼 패턴

- 2.4.1에서 선택한 인프라 위에 애플리케이션을 배포하는 것을 자동화 해야한다.
- 마틴 파울러가 언급했듯, 마이크로서비스를 수동으로 배포한다면 혼란을 가져온다.
- 자동화된 빌드나 배포를 CI/CD라고 한다
- CI
	- 지속적 통합
	- 형상관리시스템에서 코드를 가져와 통합하고 빌드 및 테스트를 진행한 후 결과를 기록한다
- CD
	- 지속적 제공, 지속적 배포
	- 실제 서버에 배포하는 과정을 의미한다.

<br>

- 운영 관리 요소의 탄생
	- 인프라 선택 / 애플리케이션을 인프라에 자동으로 빌드 및 배포한 후에는 적절하게 마이크로서비스를 운영해야한다.
	- 발전 과정
		- EC2 등장
		- 넷플릭스. 비디오 대여 사업에서 스트리밍 사업시작
		- 데이터베이스 서버가 날라감에 따라 EC2 사용 및 마이크로서비스로 이전
		- MSA를 사용함에 따라 여러 문제들이 발생. 
		- 위 문제들을 해결한 라이브러리를 오픈소스로 공개했다. netflix oss
	- 스프링 진영에서는 netflix oss와 spring boot를 결합해 sping cloud 공개

- 서비스 디스커버리 패턴
	- MSA 환경에서는 원격 호출을 통해 서비스를 사용하는 일이 잦다.
	- 서버가 생성되고 삭제되는 일이 잦아 서비스의 주소가 변경되는 일이 잦다.
	- 제 3자가 서비스 명과 주소를 기억하는 패턴을 서비스 디스커버리 패턴이라고 한다.
		- 넷플릭스 oss의 eureka가 이 기능을 담당
	- 과정
		- 서비스 인스턴스가 등록될 때 서비스 레지스트리에 자신의 정보를 서비스 레지스트리에 등록한다.
		- 클라이언트의 요청이 온다면 서비스 레지스트리에서 원하는 서비스의 주소를 얻어온다.

- BFF 패턴
	- Backend for Frontend
	- 최근에는 웹 뿐만 아니라 모바일 및 다양한 클라이언트들이 등장하게 되었다.
	- 이에 따라 클라이언트마다 다른 API 조합을 제공하기 위해 사용하는 기술이 BFF이다.
		- 클라이언트마다 최적화가 가능하다
	- API Gateway처럼 진입점을 하나로 두는 대신 각 클라이언트마다 진입점을 둔다
		- 이후에 통합적인 API Gateway를 둠으로써 공통적인 처리 로직을 수행할 수 있다.

- 인증/인가 패턴
	- 모놀리틱 방식
		- 서버 세션에 사용자의 권한, 인증정보를 저장해서 사용
		- 마이크로서비스는 수평확장이 자주 일어나므로 세션 정보가 사라질 위험이 있다.
		- 위 이유로 각 서비스마다 세션을 저장하는 대신 공통적인 세션 저장소를 사용한다.
			- 레디스나 맴캐시를 사용한다

- 서킷 브레이커 패턴
	- A 서비스가 B 서비스를 호출 할 때 B 서비스에 장애가 발생하면 A 서비스에도 장애가 발생한 것 처럼 느낀다.
	- 실시간으로 모니터링을 해서 B 서비스에 대한 호출을 N번 시도 한 후 정상이 아니라면 fallback 메서드를 호출해서 사용자가 정상적인 응답을 받을 수 있도록 한다.

- 이스티오
	- 모놀리틱 방식에서 마이크로서비스 방식으로 변경되면서 생기는 문제점들을 해결하는 패턴들을 알아보았다.
	- 1세대 방식 spring cloud와 netflix oss가 결합된 방식의 문제점
		- 서비스 레지스트리, 컨피스 서비스를 따로 구현을 해야하고
		- 마이크로서비스에서 사용하는 클라이언트 라이브러리를 비즈니스로직과 함께 탑재
	- 위 문제점을 해결하기 위해 이스티오 도입
		- 쿠버네티스와 결합되어 운영을 위한 서비스들을 기본적으로 제공한다.
		- 컨테이너 안에 팟과 Envoy가 포함되어있다.

- 통신방식
	- 동기방식
		- 프론트엔드에서 백엔드 API를 호출할 때 주로 사용하는 방식
		- 라우팅 및 로드밸런싱을 위해 API 게이트웨이를 앞에 둘 수도 있다.
		- 요청에 대한 응답을 기다리기 때문에 직관적이고 구현이 쉽지만 서비스간 결합이 강해진다
	- 비동기 방식
		- 메세지 방식의 비동기 방식을 사용하면 각 서비스들이 메세지 브로커에 의존하므로 서비스 결합도가 낮아진다.
		- 카프카, 래빗앰큐 등이 있다.

- 저장소 분리 패턴
	- 서비스가 모듈별로 구분은 되어있으나 하나의 저장소만 사용하는 경우가 많다.
	- 국내 기업을 살펴보면 서비스 코드 대비 SQL 관련 코드가 많다.
	- scale out하더라도 저장소가 분리되어있지 않으면 서비스는 한가하나 데이터베이스는 바쁜 상황
		- sql 구문 최적화를 하거나
		- 데이터베이스 서버 증설
	- 각 서비스마다 데이터베이스를 사용하도록 하자
		- 데이터베이스를 자유롭게 선택할 수 있다는 장점 (폴리글랏 저장소)
		- 각 서비스가 제공하는 API만을 통해서 데이터베이스에 접근 (정보은닉)

- 저장소 분리에 따른 문제
	- 기존에는 존재하지 않았던 데이터 정합성 문제
	- 2단계 커밋 방식으로 해결할 수도 있다.
		- 문제점
			- 하나의 큰 트랜잭션으로 묶어서 락을 거는 방식이여서 성능 문제
			- 2단계 커밋을 지원하지 않는 데이터베이스도 존재
			- 분산된 환경에서는 네트워크 문제가 가장 문제. 만약 커밋을 제대로 전달하지 않으면 다른 서비스들이 즉시 영향을 받는다.
	- 사가 패턴
		- 여러 트랜잭션을 큰 트랜잭션으로 묶는 대신 보상 트랜잭션 개념 도입
		- 로컬 트랜잭션을 순차적으로 실행. (A → B → C) 
		- B 트랜잭션의 실패로 A 트랜잭션이 롤백되어야하면 A에게 보상 트랜잭션을 실행한다.

- CQRS
	- 사가패턴은 데이터 일관성이 실시간으로 일치해야한다는 관념을 깨서 가용성을 극대화
	- CQRS도 읽기 쓰기가 하나의 데이터베이스에서 이루어져야한다는 개념을 깨면서 출발
	- 조회 API 횟수 ≥ 쓰기 API 횟수. 읽기 저장소와 쓰기 저장소를 분리한다.
		- 쓰기 저장소에 적합한 데이터베이스 선택
		- 읽기 저장소에 적합한 데이터베이스 선택가능(NoSQL)
	- 쓰기 저장소와 읽기 저장소간 데이터 정합성은 이벤트 기반 아키텍쳐로 해결한다.

- Event sourcing
	- 객체 상태 변화에 대한 이벤트 발행 + 데이터베이스에 해당 상태를 반영한 후 저장하는 로직의 문제점
		- 느리다
		- 객체와 데이터 사이의 불일치
	- 최종적으로 반영될 데이터를 저장하는 대신 모든 트랜잭션을 기록

# 3장.  마이크로서비스 애플리케이션 아키텍쳐

- 구조적으로 설계를 잘 해야 유지보수가 용이하다.
- 레이어드 아키텍쳐
	- 표현 - 응용 - 데이터베이스로 크게 구분한다.
	- 상위 레이어는 하위 레이어에 의존하는 형태를 띤다 → DIP, 관점에 따라서는 OCP를 만족하지 못하므로 
		- 상위 레이어에서 인터페이스 정의 + 하위 레이어에서 해당 인터페이스를 구현 → DIP를 만족한다.

> [!info] OCP vs DIP
> - OCP : 소프트웨어 구성요소는 확장에는 열려있고 수정에는 닫혀있다. 하나의 모듈내에서 적용되는 개념이라고 이해했다.
> - DIP : 기본적인 정의는 구체 클래스에 의존하는 대신 추상화에 의존해야한다
> 	- 모듈로 이야기를 하자면 하위 모듈이 상위 모듈에 의존하도록 한다 → 인터페이스를 상위 모듈을 기준으로 한다. DIP는 여러 모듈 사이에서 이야기

- 헥사고날 아키텍쳐
	- 현대에서 레이어드 아키텍쳐는 적합하지 않다. 
		- 왜요? 애플리케이션에 접근하는 다양한 인터페이스를 지원하기 어렵다
	- 헥사고날의 구조
		- 내부영역
			- 고수준의 비즈니스 로직을 담고 있다.
			- 외부영역과 소통하기 위한 포트를 갖고 있다.
		- 외부영역
			- 내부영역과 소통한다
			- 인바운드, 아웃바운드 어뎁터가 있다.
- 클린 아키텍쳐
	- 로버트.c 마틴이 제안
	- 소프트웨어를 부드럽게 하는 것은 선택 가능한 것을 가능한 한 열어두는 것
	- 엔티티 - 유스케이스 - 세부사항 으로 분리할 수 있다.
- 내부 영역 구조설계
	- 트랜잭션 스크립트 패턴
		- 도메인 객체는 단순히 데이터를 저장
		- 비즈니스 로직은 서비스가 담고 있음 → 서비스가 거대해지는 문제 발생
		- 절차지향적, 객체 지향적이지 않다
	- 도메인 객체 패턴
		- 도메인 객체는 비즈니스 로직을 담고 있음 → 도메인 서비스
		- 애플리케이션 서비스는 도메인 서비스를 이용하여 흐름을 정의 → 서비스가 작아진다
		- 객체지향적
	- 애그리거트 패턴
		- 객체들이 많아지면 복잡해진다
		- 애그리거트로 나누어 애그리거트 루트끼리 참조 대신 키값을 사용

# 5장.  마이크로서비스 설계

- 모듈을 분리하는 것은 소프트웨어 개발에 있어서 중요하다.
- 하나의 마이크로서비스 내에서 모듈이 잘 분리되어 있어야 하고 마이크로서비스간 의존성도 낮아야 한다.
- 자세한  사항은 [마이크로서비스 개발을 위한 Domain Driven Design](https://www.youtube.com/watch?v=QUMERCN3rZs)에서 자세히 설명하니 꼭 살펴보자.



