 <p align="center">
	<img src="https://github.com/devbelly/TIL/assets/67682840/420a6940-d457-4573-8ccd-f421463d4e09">
</p>
# 1장. 아마존 비즈니스 민첩성의 비밀

### 1.1.1 성공사례 : 아마존의 빠른 배포속도가 의미하는 것은 무엇일까?
- 2019년 아마존은 초당 1.5번의 배포를 했다고 한다.
- 위 지표는 결국 비즈니스 민첩성을 나타내고 시장 변화에 빠르게 적응한다는 뜻이다.

### 1.1.2 성공원인 첫번째, 클라우드 인프라의 등장
- 예전에는 인프라를 구축하는데 시간이 매우 오래 걸려서 애플리케이션을 개발할 여유가 되도 시간이 오래걸렸다.
- 클라우드 회사의 등장으로 이 문제가 해결됨.

### 1.1.3 클라우드 인프라에 어울리는 애플리케이션 조건
- 인프라와 애플리케이션을 나눠서 보자
- 클라우드 인프라의 등장으로 필요할때만 인프라를 증설해서 트래픽에 대처하고 다시 인프라를 반납할 수 있다.
- 애플리케이션도 필요한 부분만 수정해서 배포하면 좋지 않을까?

> [!faq] 왜 마이크로서비스로 구성했는가?
> - 애플리케이션의 특정 모듈에만 트래픽이 예상된다면 해당 모듈만 scale-up, scale-out 하면 되기 때문에 효율적이다.
> - 변경된 모듈만 재배포하면 되므로 가볍다

## 1.2 마이크로서비스란 무엇인가?

> [!faq] 모놀리틱서비스란 무엇인가?
> - 논리적으로 하나의 단일체로 구분되며 작은 배포에도 전체가 재배포되는 거대한 서비스를 의미한다.
> - 애플리케이션이 수평확장 되어있을 때 작은 변경에도 모든 애플리케이션을 재배포해야한다.
> - 하나의 데이터베이스만 사용하므로 데이터베이스는 탄력적으로 대응할 수 없다는 단점이 있다.

> [!faq] 마이크로서비스란 무엇인가?
> - 서버가 여러개의 서비스로 나뉘어서 여러 인스턴스가 논리적으로 하나의 서비스를 제공하는 형태

> [!faq] 모놀리틱과 비교했을 때 어떠한 이점을 갖나요?
> - 각기 다른 저장소를 가지고 있을 수 있다.
> - 각 서비스 마다 다른 언어로 개발할 수 있다.
> - 분리된 서비스 단위로 빌드 및 배포하여 효율적이다.

### 1.2.2 SOA와 마이크로서비스

> [!faq] SOA와 마이크로서비스는 어떠한 차이가 있나요? 그리고 차이를 가능케한 MSA 만의 특징이 있나요?
> - SOA와 마이크로서비스는 분리된 서비스를 합쳐 논리적으로 하나의 큰 서비스를 제공한다는 측면에서는 비슷하다.
> - SOA는 개념적으로만 존재했지만 MSA는 이를 실현하여 성공한 사례가 많다.
> - SOA는 하나의 데이터베이스를 사용하여 개념적으로는 분리했지만 구현상으로는 데이터의 강결합 문제가 발생했다.
> - MSA는 각 서비스마다 저장소를 두고 다른 서비스의 저장소를 직접 호출하는 대신 API 를 통해 접근하도록 함으로써 저장소의 분리를 성공시켰다.

> [!faq] 2단계 커밋을 마이크로서비스에서는 왜 사용하지 못하나요?
> - NoSQL처럼 2단계 커밋을 지원하지 않을 수 있따.
> - 느슨한 결합이 목적인 MSA에서 데이터베이스간 강결합이 발생한다

> [!faq] 결과적 일관성에 대해 설명해주세요
> - 저장소마다 로컬트랜잭션을 수행하고 특정 순간에는 데이터의 불일치가 있을 수 있지만 보상트랜잭션을 통해 결과적으로는 데이터 일관성을 갖게된다는 의미입니다.


# 2장. MSA 이해

> [!faq] 아키텍쳐라는 단어는 무슨뜻일까요?
> - 소프트웨어 구성요소와 구성요소간의 관계를 나타내는 단어입니다. 

#### VM과 컨테이너

> [!faq] VM과 컨테이너의 차이점은 무엇일까요?
> - VM은 하이퍼바이저 위에 여러개의 OS 게스트가 올라가있는 형태이다
> - 컨테이너는 컨테이너 엔진 위에 이미지를 실행하는 형태.
> - VM은 운영체제 패치 및 라이브러리 설치에 오버헤드가 발생하지만 컨테이너는 이러한 오버헤드가 발생하지 않는다.

> [!faq] 도커의 장점이 무엇일까요?
> - 이식성
> - 가벼움
> - 재사용성

#### 다양한 서비스의 등록 및 탐색을 위한 서비스 레지스트리, 서비스 디스커버리 패턴

> [!faq] 서비스 디스커버리 패턴은 무엇인가요?
> - 원격 서비스에 접근하기 위해서는 IP와 Port 정보를 알아야하지만 컨테이너 기반 환경에서는 IP가 변경되는 일이 잦다.
> - 서비스가 등록될 때 서비스 레지스트리에 서비스의 IP와 포트 정보를 등록하고 클라이언트는 서비스 레지스트리에 접근해서 서비스에 대한 접근 정보를 알아가는 패턴이 서비스 디스커비리이다.


> [!faq] BFF 패턴은 무엇인가요?
> - Backend for Frontend
> - 다양한 종류의 클라이언트들이 많아짐에 따라 클라이언트마다 사용할 API 조합을 백엔드에서 제공하는 형태이다.
> - 클라이언트마다 BFF 서버를 두고 BFF 들이 하나의 API 게이트 웨이를 바라보게 하면 인증/인가를 한 곳에서 처리할 수 있다.

#### 외부 저장소 패턴

> [!faq] 외부 저장소가 무엇인지 말하고 외부 저장소 패턴이 필요한 이유는 무엇인가요?
> -  외부 설정 정보를 저장하는 곳을 외부 저장소라고 한다. 클라우드 환경에서 설정 정보가 애플리케이션에 포함되어있으면 정보 변경시 재배포 되어야하고 이는 서비스 중단으로 이어진다. 외부 저장소에 설정 정보를 저장하고 동적으로 애플리케이션을 읽어오면 이 문제를 해결할 수 있다.
> - 쿠버네티스에서 ConfigMap 등을 제공한다


#### 장애 및 실패 처리를 위한 서킷 브레이커 패턴

> [!faq] 서킷 브레이커 패턴에 대해 설명해주세요
> - 마이크로서비스에서 가장 문제가 많이 발생하는 원인은 아이러니하게도 서비스 분리이다. A 서비스가 B 서비스에 의존하고 있을 때 B 서비스에 장애가 발생하면 A까지 장애가 전파된다. 이를 해결하기 위해 서킷 브레이커 패턴이 도입. B 서비스에 장애가 발생하면 여러번 리트라이 이후 대체 응답을 클라이언트에 리턴하고 나중에 B가 정상화되면 다시 클라이언트에게 정상 응답을 돌려주는 패턴이다.


#### 서비스 메시 패턴

> [!faq] 서비스 메시 패턴에 대해 설명해주세요
> - 마이크로서비스에서 서비스간 통신, 로깅, 보안을 지원하는 플랫폼입니다. 대표적인 오픈소스로 istio가 있습니다. 사이드카 패턴을 통해서 개발자가 비즈니스 로직에 집중하도록 합니다.

#### 분산 트랜잭션 처리 패턴

> [!faq] SAGA 패턴에 대해 설명해주세요
> 분산된 노드의 트랜잭션을 하나로 묶는 것이 아니라 로컬 트랜잭션을 순차적으로 실행하면서 일관성을 맞추는 패턴입니다. 롤백에 대한 처리는 보상 트랜잭션을 통해서 결과적 일관성을 추구하는 패턴입니다. 

> [!faq] CQRS에 대해 설명해주시고 장점도 말씀해주세요.
> - 명령과 조회에 대한 책임을 분리하는 패턴입니다. CRUD가 모여있는 인스턴스를 스케일아웃하면 CUD로 인해 R가 지연될 수 있으므로 조회와 업데이트를 분리합니다. CUD 저장소에 데이터를 저장하면 이벤트를 통해서 R 저장소를 업데이트하는 방식입니다.

# 3장. MSA 애플리케이션 아키텍쳐

- 비즈니스로직과 구현 기술은 분리되어야한다.
- ❓흐름제어로직, 비즈니스로직의 차이

> [!faq] 레이어드 아키텍쳐란 무엇인가요?
> - 물리 장비인 서버를 논리적으로 세 개의 계층(일반적으로)으로 나눈 아키텍쳐입니다. 보통 프레젠테이션, 비즈니스로직, 데이터 계층으로 나눌 수 있습니다.

- 고수준의 비즈니스로직 계층은 저수준의 변경에 영향을 받아서는 안된다.

> [!faq] 레이어드 아키텍쳐 + DIP에는 어떤 문제가 있어 헥사고날을 사용해야하나요?
> - 현대에는 애플리케이션에 접근하는 다른 유형의 서비스가 많기 때문에 이러한 인터페이스를 지원하기 위해서 헥사고날을 사용하는 것이 좋습니다.

> [!faq] 헥사고날 아키텍쳐를 다른 말로 무엇이라고 하나요?
> - 포트 앤 어댑터 아키텍쳐

#### 클린 아키텍쳐

- 유스케이스
	- 애플리케이션에 특화된 업무 규칙을 표현한다
	- 🤔 도메인 주도 개발 시작하기 책에서 Domain service vs Application service에서 Application Service를 나타내는 것 처럼 보인다. 로직이 들어가지있지 않고 하위 로직을 조합해서 사용하는 느낌이다.
	- 📖p97. 서비스와 도메인은 클린 아키텍쳐의 유스케이스와 엔티티의 역할과 같다.

#### 3가지 아키텍쳐가 지향하는 원칙

- 지향하는 관심사에 따라 응집성을 높이고 관심사가 다른 영역과는 의존도를 낮춘다.
- 비즈니스 로직을 기술 영역과 분리해야한다.
- 고수준은 저수준 영역에 의존하지 않으며 저수준은 고수준 영역에 의존한다.

#### 패턴

> [!faq] 애그리거트 패턴이 무엇인가요?
> - 도메인 모델 패턴에서 발전된 형태. 엔티티간 관계를 매핑할 때 참조를 사용하면 간편하지만 도메인간 경계가 불확실해지는 단점이 있다. 이를 해결하기 위해 루트 엔티티를 통해 서로 참조하며 참조 시 PK를 사용하도록 한다.

### 3.3.3 외부영역
- 외부영역은 내부 영역의 서비스 인터페이스를 사용하는 인바운드 어댑터와
- 내부영역에서 선언한 아웃바운드 인터페이스를 구현하는 어댑터로 구성된다.

# 5장. DDD 설계

> [!faq] 유비쿼터스 언어란 무엇인가요?
> - 기존에는 도메인 전문가와 개발자, 고객이 사용하는 언어가 달라 용어집을 사용했다. 이러면 의사소통 과정에서도 코스트가 발생하는 비효율이 있다.
> - 유비쿼터스 언어는 특정 도메인 영역에서 사용하는 비즈니스 용어로써 기획 및 소스코드에서 사용되는 언어가 일치한다. 예를 들어 결제 서비스와 배송 서비스에서 고객이라는 언어를 사용한다면 서로의 관심사가 다르다. 결제에서는 고객의 카드정보 등이 필요하지만 배송에서는 고객의 주소정보 등이 필요하다. 즉 결제자, 수취자라는 개념으로 각자의 도메인에서 사용할 수 있다.

## 5.4 이벤트 스토밍 

#개인프로젝트

<img width="482" alt="image" src="https://github.com/devbelly/TIL/assets/67682840/4960b4f2-fa5c-4f3a-8fcc-371294df7a8c">
<img width="702" alt="image" src="https://github.com/devbelly/TIL/assets/67682840/01a2076b-f2c3-4118-94dd-c15f217dc48d">
<img width="687" alt="image" src="https://github.com/devbelly/TIL/assets/67682840/e999d4c4-7449-4cf5-b939-951513557c7c">

<img width="382" alt="image" src="https://github.com/devbelly/TIL/assets/67682840/c0c7bc54-d19d-4ce9-9702-b31247b73342">

#### 5. 액터도출
- 특정 비즈니스를 실제로 수행하는 판매자, 구매자를 도출하도록 노력해야한다.
	  <img width="353" alt="image" src="https://github.com/devbelly/TIL/assets/67682840/b3d13134-37d8-4313-ba97-516cc85a4b44">

#### 6. 애그리거트
- 커맨드와 이벤트에 영향을 주는 구성요소
- 도메인을 실질적으로 표현하는 엔티티가 된다.
- 🤔배송, 발송, 수령을 노란색 애그리거트로 나누네. 상품과 재고수량을 나누는 것도 독특해

#### 8.정책
- 정책은 항상 다른 커맨드를 실행한다.
- 정책은 도메인 이벤트와 커맨드 사이에 존재한다.


### 5.5.2 

**인바운드 포트**
- 내부 영역을 사용하기 위한 API
- 유스케이스로 작성되며 인바운드 어댑터가 인바운드 포트에 접근한다.

**아웃바운드 포트**
- 내부영역이 외부영역을 사용
- 아웃바운드 어댑터에서 이를 구현하는 형태이다.

어댑터
- 언제든지 교체 및 확장 가능해야한다.

#### API 퍼블리싱 어댑터
- REST API를 발행하는 인바운드 어댑터이다.
- 내부 영역의 서비스 인터페이스(인바운드 포트, 유스케이스)를 호출해서 REST 형식의 API로 제공한다.

#### API 프락시 어댑터
- 다른 서비스의 API를 호출하는 아웃바운드 어댑터

> [!faq] REST API란 무엇인가요?
> - HTTP 기반 네트워크 통신 아키텍쳐
> - 자원, 동사, 표현으로 이루어져 있다.
> - 자원은 `localhost:8080/user/` 처럼 URI 형식으로 나타남.
> - 동사는 GET, POST 등
> - 표현은 `hongildong` 

> [!faq] 값객체와 엔티티의 차이점은 무엇인가요?
> - 엔티티는 PK와 내부 상태가 변한다
> - 값객체는 PK가 없고 생성되면 내부 상태가 변하지 않는다

#### 애그리거트
- 값객체와 엔티티를 구성하면 계층이 생긴다. → 이러한 계층을 하나로 묶은 것이 애그리거트
- 바운디드 컨텍스트간 일관성은 이벤트로 처리한다.

# 6장. 사례연구

> [!info] bookCatalog mongobee 관련 에러
> <img width="955" alt="image" src="https://github.com/devbelly/TIL/assets/67682840/da50394d-26d3-4e36-8488-32612a42a063">

# 7장.

- Rental의 개념은 도서 대출이다. 모든 사용자는 대출을 위한 Rental 엔티티를 하나씩 보유한다. Rental 엔티티는 대출, 반납, 연체에 대한 책임을 가진다.

> [!faq] 페인이 무엇인가요?
> REST 방식의 동기 서비스 호출을 지원합니다. 간단한 인터페이스 구현만으로 서비스 호출에 대한 구현을 제공해 간단하게 외부 서비스를 호출할 수 있습니다.


> [!faq] DTO를 사용하는 이유는 무엇일까요?
> 도메인에 대한 의존성을 낮추기 위해서입니다. 


<img width="732" alt="image" src="https://github.com/devbelly/TIL/assets/67682840/89f877c8-143f-4140-ae4c-59bf49a8d4da">
- 특이한점은 `RentalProducer`는 내부영역에 속하는 것이다.
	- 의존성 역전 원칙을 적용한 것이다. 일반적으로 도메인은 인프라에 의존하지만 반대로 인프라가 도메인에 의존하도록 한다. 
	- 위 이유로 카프카 말고 다른 메세지 큐를 사용하고 싶다면 변경할 수 있다.

p 283

- 만들면서 배우는 클린아키텍쳐 ~
- jwt~
---
개인생각
- 🤔 p136. 상품정보 수정됨, 상품재고 수정됨은 다른 애그리거트로 표시되는건가?
- 🤔 p137. 배송완료됨의 커맨드는 상품수령이군
- 🤔 p170. 라일락색 정책은 같은 서브도메인도 호출가능하군. 외부의 서브도메인의 커맨드만 호출하는 줄 알았네
- 🤔 p172. 회원과 로그인을 바운디드 컨텍스트로 분리한 이유를 모르겠다. 굳이..?
- 🤔 p234. 모든 사용자는 대출을 위한 Rental 엔티티를 가진다는데, User 엔티티에 직접 보유를 한다는 건가? 아니면 Rental 엔티티에 그냥 userId로 표시를 한다는 건가?
- 🤔 p286. `check`와 관련된 메서드를 어디서 수행해야하는지 도메인 주도 개발 시작하기 책에서 있었는데 개발 시작하면서 확인해봐야겠다.


---
메모
- 2단계 커밋
- 세션
---











