<p align="center">
  <img src="https://github.com/devbelly/TIL/assets/67682840/0b619ae5-6e47-4736-8107-b4966eb7871d">
</p>

# 1. 도메인 모델 시작하기

## 1.1 도메인이란?

> [!info] 도메인이란?
> - 소프트웨어로 해결하고자 하는 문제영역을 의미한다.

- 도메인은 하위 도메인으로 나뉠 수 있다.
	- 쇼핑몰이라는 큰 도메인은 결제, 정산, 배송, 할인 등 하위 도메인으로 나눌 수 있다.
- 하나의 도메인에서 모두 처리하기 보단 외부 시스템과 연계할 수도 있다.

## 1.2 도메인 전문가와 개발자와의 대화

- 각 도메인 전문가마다 자신의 경험치를 토대로 요구사항을 말한다.
	- 회계사는 엑셀에 있는 내용을 특정 방식으로 자동화
	- AS기사는 사용자에게 보낼 내용에 대한 템플릿 생성
- 요구사항은 첫단추와 같아 항상 자세히 분석해야한다.
	- 도메인 전문가와 개발자 사이에 많은 사람이 개입한다면 요구사항이 변질될 가능성이 높다.

## 1.3 도메인 모델

> [!info] 도메인 모델이란?
> - 도메인을 이해하기 위해 개념적으로 표현한 것.

- 도메인 모델을 표현할 때는 다양한 방법을 사용할 수 있다.
	- 객체 모델
	- 그래프
	- 다이어그램
- 도메인 모델을 구현하기 위한 물리 모델은 최대한 표현 방식을 따를 수 있다.
	- 객체 모델을 선택했다면 객체지향적인 언어를 선택
	- 수학적인 모델을 선택했다면 함수형 언어를 선택

## 1.4 도메인 모델 패턴

- 아키텍쳐에서 도메인 계층을 구현할 때 객체지향적으로 도메인을 설계하는 것을 도메인 모델 패턴이라고 한다.
- 도메인 계층에는 도메인의 핵심 규칙을 구현한다.
	- 주문 도메인의 핵심 규칙
		- 출고전에는 배송지를 변경할 수 있다.
		- 배송시작전이라면 주문을 취소할 수 있다.
		- etc
- 핵심규칙(예를 들어 배송지 변경)이 `Order.class`에 속하든 `OrderState.class`에 속하는지 상관없이 도메인 모델 내애 속해있으면…
	- 변경 시 다른 코드에 영향을 덜 준다.

> [!info] 도메인 모델?
> - 도메인을 개념적으로 표현할때 도메인 모델이라는 표현을 사용
> - 도메인 계층을 표현한 객체 모델을 언급할때도 도메인 모델이라는 표현을 사용

## 1.5 도메인 모델 도출

- 도메인을 구성하는 핵심요소, 규칙, 기능을 파악하는 것에서 출발한다.
	- 위 내용의 기초가 되는 것은 요구사항을 분석
- 한 상품을 한개 이상 주문할 수 있다 + 각 상품의 구매 가격 합은 상품 가격에 갯수를 곱한 값이다.
	- OrderLine에는 `Product`, `amount`, `price` 가 핵심 요소이다.
	- OrderLine에는 `getTotalAmount` 기능이 필요하다
- 최소 한 종류 이상의 상품을 주문해야한다 + 총 주문 금액은 각 상품의 구매 가격 하블 모두 더한 금액이다
	- Order과 OrderLine의 관계를 알 수 있다.
	- Order에는 `calculateTotalAmount` 기능이 필요하다

# 1.6 엔티티와 벨류

- 도출한 도메인 모델은 엔티티와 벨류로 구분할 수 있다.
- 엔티티의 가장 큰 특징은 식별자가 있다는 것이다.
	- 엔티티의 생성, 수정, 삭제까지 한번 생성된 식별자는 변하지 않는다.
	- 엔티티의 식별자가 같다면  동일한 엔티티로 판단. `equals()`와 `hashCode()`를 오버라이딩 할 수 있다.
- 식별자는 다음과 같은 방법으로 구할 수 있다.
	- DB에 맡기기
	- UUID
	- 특정 규칙에 따라 생성
- 벨류는 개념적으로 완전한 하나를 표현하기 위해 사용한다.
	- `ShippingInfo.class`에 `private String receiverName` 필드와 `private String receiverPhoneNumber` 필드가 존재
	- 이 필드들은 개념적으로 `수신인` 이라는 개념을 표현하는 중이므로 두 필드를 묶어 `Receiver`라는 클래스를 만들 수 있다.
		- `Receiver`는 벨류 타입이 된다.
	- 벨류 타입은 두개 이상의 필드를 사용해야만 하는 것은 아니다.
		- 개념적으로 의미를 잘 드러닐 수 있으면 하나의 필드를 사용할 수 있다.
	- 벨류 타입만의 메서드를 제공할 수 있다.
	- 벨류 타입의 값을 변경할 때는 새로운 객체를 리턴하는 방식을 사용한다.

		```java
		public class Money{
			private int price;
		
			public Money add(Money added){
				return new Money(this.price+added.price);
			}
		}
		```
		- 불변 객체로써 안전한 코드를 작성할 수 있게 된다.
		- Money가 가변객체라면 전달받은 파라미터(added)를 복사해서 사용해야한다.
		- Money가 불변 객체라면 복사할 필요 없이 바로 사용할 수 있다.

### 1.6.3 도메인 모델에 set 넣지 않기

- 프로그래밍을 하다보면 무분별하게 `get`과 `set`을 사용한다.
- 도메인 모델에 세터를 두면 단점이 생긴다!
	- 도메인 모델의 핵심 로직을 잃게 된다.
	- 도메인 모델 생성시 객체가 온전치 않은 상태로 존재할 수 있다.

> [!faq]- 도메인 모델의 핵심 로직을 잃게 된다?
> - `changeShippingInfo()`는 새로운 배송지로 변경한다는 의미를 담고 있지만 `setShippingInfo`는 단순하게 배송지를 설정하는 의미를 담는다.
> - `completePayment`는 결제 완료의 의미를 담지만 `setOrderStatus`는 단순히 상태 변경만을 나타낸다.
> - `completePayment`는 결제완료와 관련된 도메인 지식을 코드에 담는 것이 자연스럽다
> - `setOrderStatus`는 상태만 변경할지 해당 상태 변경에 따른 추가 로직이 필요할지 판단하기 어렵다. 즉 도메인 지식을 코드에 녹여내기 어렵다. 
> → `set`을 사용하면 도메인 지식을 코드에 녹여내기 어렵다.


## 1.7 도메인 용어와 유비쿼터스 언어

- 코드 작성 시 도메인 용어와 변수명을 최대한 일치시켜야한다.
	- 그렇지 않으면 용어 전환에 따른 비용이 발생
	- 예를 들어 개발자가 STEP1, STEP2, STEP3 와 같이 표현하면 각각이 무슨 의미인지 파악하기까지 시간이 걸린다.
- 각 도메인 전문가와 개발자는 시간이 지남에 따라 도메인에 대한 이해도가 높아진다.
	- 전문가들끼리 의사소통에 사용하는 언어를 유비쿼터스 언어라고 한다.

# 2장. 아키텍쳐 개요

## 2.1 네 개의 영역

- 표현, 응용, 도메인, 인프라스트럭쳐로 나눌 수 있다.
- 표현
	- 사용자에게 보여지는 영역을 담당한다.
	- 사용자 요청을 응용 영역이 필요한 데이터로 변환하거나 응용 영역의 결과를 사용자가 필요한 형태로 반환한다.
		- 객체와 json 변환 담당
- 응용
	- 사용자에게 필요한 기능을 구현. 구현 시 도메인 모델을 활용한다.
	- 코드
	```java
	public void OrderCancel(String orderId){
		Order order = findOrderById(orderId);
		if(order == null) threw new Exception():
		order.cancel();
	}
	```
	- 직접 로직을 수행하는 대신 도메인 모델에 로직 수행을 위임한다.
- 도메인
	- 도메인의 핵심 로직을 구현한다.
- 인프라스트럭쳐
	- 기술 구현에 대한 상세를 다룬다

## 2.2 계층 구조 아키텍쳐

- 표현 - 응용 - 도메인 - 인프라스트럭처를 계층 구조로 사용한다.
- 상위 계층은 하위 계층에 의존적이며 하위 계층은 상위 계층에 의존적이지 않다.
	- 엄격히 적용하면 상위 계층은 바로 아래 있는 하위 계층에만 의존해야하지만 구현의 편리함을 위해 포기할 수도 있다.
- 계층 구조는 직관적이지만 표현, 응용, 도메인 영역이 인프라스트럭처 계층에 매우 의존적인 형태를 띠게 된다.
- 예를 들어 `OrderDiscountService`가 인프라스트럭처 계층의 `DroolsRuleEngine`에 의존하고 있다 해보자.
	- 문제점
		- `OrderDiscountService`를 테스트하기 위해서는 `DroolsRuleEngine`이 존재해야한다.
		- `OrderDiscountService`에서 코드를 변경하기 어렵다.
			- 실제로 `DroolsRuleEngine`이 제공하는 객체를 사용하지 않더라도 로직 자체가 간접적으로 의존하게 되어있다. (전달하는 파라미터, 결과값을 위해 사용하는 객체 등등)
	- 해결책
		- DIP를 사용하자

## 2.3 DIP

- `OrderDiscoutService`는 아래 두 하위 모듈을 통해 서비스를 제공한다
	- 고객 정보를 구해온 후
	- 룰을 이용해서 할인 금액을 구한다.
- `OrderDiscountService` 입장에선 할인 금액을 구하는 것이 중요하지 해당 로직을 구현할 때 java로 구현한지 Drools로 구현한지는 관심 밖이다.
	- 추상화된 인터페이스를 제공함으로써 상위모듈이 하위 모듈에 의존하는 형태를 분리해내자.
	- 코드
	```java
	interface RuleDiscounter{
		Money applyRules(Customer customer, List<OrderLine> orderLines);
	}
	```
- 하위모듈인 `DroolsRuleEngine`은 `RuleDiscounter`를 구현함으로써 하위 모듈이 상위모듈에 의존하게 된다. → DIP 적용
	- 구현 객체를 변경하더라도 상위 모듈은 변경될 필요가 없다.
	- 테스트시 실제 클래스가 존재할 필요 없이 Mock를 사용하면 된다.

## 2.4 도메인 영역의 주요 구성요소

- 엔티티와 벨류
	- 엔티티는 식별자로 구분되어 하나의 라이프사이클을 가진다
	- 벨류는 개념적으로 하나로 표현하기 위해 사용하는 객체
	- DBMS 객체 vs 도메인 엔티티 객체
		- 도메인 객체는 데이터의 저장뿐만 아니라 기능 구현까지 제공한다.
		- 기능을 제공함으로써 객체가 허용된 범위 밖에서 변경되는 것을 방지할 수 있다.
		- 벨류 객체를 온전하게 사용할 수 있다.
			- DBMS에서는 벨류 객체를 하나의 엔티티로 저장하거나 파라미터로 늘어놓는 형태.
			- 도메인 엔티티에서는 벨류 객체를 온전하게 사용함으로써 엔티티에 대한 이해도가 증가
- 애그리거트
	- 개발을 진행하다보면 엔티티와 벨류가 많이짐에 따라 모델 또한 커진다
	- 개발자는 큰 개념에 집중하기 보다 개별 엔티티에 집중하게 되어 전체 구조 제대로 파악하지 못할 수 있다.
	- 관련 있는 엔티티와 벨류를 상위 개념으로 묶은 것이 애그리거트이다.
	- 주문 애그리거트에는 주문 엔티티, 주문자 벨류, 주문목록 엔티티 등 여러 엔티티와 벨류들이 모일 수 있다.
	- 애그리거트는 루트 엔티티를 가진다
		- 루트 엔티티는 군집을 관리한다.
	- 애그리거트를 사용하는 코드는 애그리거트 루트가 제공하는 기능을 사용하고 다른 엔티티에 대한 접근을 제어함으로써 에그리거트 단위로 캡슐화 할 수 있다.

## 2.6 인프라스트럭처 개요

- 인프라스트럭처는 표현, 응용, 도메인 영역을 지원한다.
- DIP를 실현하여 변경이 용이함이나 테스트의 편리함을 챙길 수도 있지만 무조건 인프라스트럭처에 의존을 안하는게 옳지는 않다.
	- 트랜잭션처리를 스프링에서 제공하는 `@Transactional` 을 사용
	- 도메인 영역 클래스에 `@Entity`나 `@Table`을 사용
- DIP 장점만큼 구현의 편리함 또한 중요하므로 경중을 잘 따져가며 사용하자

> [!info] Domain Service vs Application Service
> - [# Domain services vs Application services 한글](https://americanopeople.tistory.com/372)
> - [# Domain services vs Application services](https://enterprisecraftsmanship.com/posts/domain-vs-application-services/)
> - [# What is domain logic?](https://enterprisecraftsmanship.com/posts/what-is-domain-logic/)
> 

- 도메인 서비스?
	- 특정 엔티티에 속하지 않는 도메인 로직을 제공한다.
	- 결제 로직을 살펴보면 상품, 주문, 할인, 주문자 등 여러 애그리거트의 조합으로 이루어져 있다.
	- 결제 로직을 `Order` 애그리거트에 억지로 넣으려고 하면 의존성이 증가하게 된다.
	- 도메인 기능을 별도 서비스로 제공 → 이를 도메인 서비스라고 한다.

- 도메인 서비스를 도입해야하는 경우?
	- 외부 서비스의 도움없이 도메인 불변성을 유지할 수 없는 경우
	- 예를 들어 ATM 엔티티는 외부 서비스인 `paymentGateWay`의 도움없이 도메인 불변성을 유지하기 어렵다
	- 이럴 때 도메인 서비스를 사용하면 도움이 된다

- 도메인 서비스 vs 애플리케이션 서비스
	- 도메인과 벨류들 위에서 동작하는 *상태없는* 클래스
	- 가장 큰 차이점은 도메인 서비스를 도메인 로직을 담고 있지만 애플리케이션 서비스는 도메인 로직이 없다

- 도메인 로직?
	- 도메인 로직을  잘 분리해야하는 이유?
		- 다른 영역(UI, persistence)으로 부터 잘 분리된 도메인 로직을 통해 도메인 파악이 매우 용이해진다.
	- 도메인 로직은 의사결정과 관련이 있다.

**예시1**

```csharp
private void TakeMoney(decimal amount)
{
    string error = _atm.CanTakeMoney(amount);
    if (error != string.Empty)
    {
        NotifyClient(error);
        return ;
    }
 
    decimal amountWithCommission = _atm.CaluculateAmountWithCommission(amount);
    _paymentGateway.ChargePayment(amountWithCommission);
    _atm.TakeMoney(amount);
    _repository.Save(_atm);
 
    NotifyClient("You have taken " + amount.ToString("C2"));
}
```

- `TakeMoney`는 애플리케이션 서비스 로직
- 돈을 인출할 수 있는지, 계산된 수수료는 얼마인지에 대한 결정은 `atm`이 내린다.
	- 핵심 로직은 도메인 클래스인 ATM이 판단한다
- `TakeMoney`는 도메인 모델이 내린 결정을 오케스트레이션 + side effect를 만든다
	- data store에 저장하기
	- user에게 보여주기
	- 3rd-party 서비스에 전달하기

- Injecting a domain service into an entity
	- 위 링크의 저자는 도메인 서비스를 `pure`한 서비스와 `impure`한 서비스로 나눴다.
	- `pure`한 서비스는 한 도메인에 닫혀있지만(해당 도메인의 엔티티 + 값객체)
	- `impure`한 서비스는 다른 도메인까지 같이 사용한다. 즉 두개를 구분하는 것을 권장한다.

# 3장. 애그리거트

## 3.1 애그리거트

- 엔티티가 복잡해지면 큰 범위에서 파악하기보단 개별 엔티티간 관계를 파악하기에 복잡하다
- 큰 단위. 애그리거트로 묶어서 보면 프로젝트 파악이 쉬워진다 → 수정이 용이해진다
- 애그리거트는 관련 객체들끼리 라이프 사이클을 거의 공유한다.
- 애그리거트를 나누는 기준은 도메인 규칙과 요구사항이 될 수 있다.
	- 도메인 규칙에 따라 주문할 상품 갯수, 배송지 정보, 주문자 정보는 함께 생성 → 하나의 애그리거트
	- 사용자 요구사항에 따라 주문 상품의 갯수와 배송지 정보를 함께 변경하기도 한다 → 하나의 애그리거트
- A가 B를 포함한다 말 자체로는 애그리거트를 나누기 어렵다
	- Order가 ShippingInfo와 Orderer를 포함한다는 개념으로는 맞는 것 같으나
	- Product와 Review는 함께 생성되지도 않고 수정되지도 않는다.
- 다수의 애그리거트가 하나의 엔티티를 갖는 경우가 많았다!!

## 3.2 애그리거트 루트

- 애그리거트 단위로 일관성이 유지되도록 해야한다.
	- OrderLine은 갯수와 가격을 담고 있는데 갯수가 변경되면 Order 엔티티의 `totalAmount` 또한 변경되어야 한다.
- 일관성을 책임지는 엔티티 → 애그리거트 루트
- 애그리거트 루트는 도메인 규칙을 적용한 메서드를 제공해야한다
	- `changeShippingInfo` : 출고전에 배송지 변경이 가능하다
- 애그리거트 루트가 아닌 외부에서 애그리거트를 변경해선 안된다.
	```java
	// 아래처럼 작성하면 안된다!
	ShippingInfo si = order.getShippingInfo();
	si.setAddress(newAddress);
	```
	- 애그리거트 일관성을 유지할 책임이 애플리케이션이나 프레젠테이션으로 옮겨지게 된다
	- 결과적으로 중복된 도메인 로직을 작성할 확률이 높아진다.
- 중복된 도메인 로직을 피하기 위해선 다음 규칙을 지키자
	- 공개된 세터 금지
	- 불변 벨류 사용
- 공개된 세터
	- 애그리거트 일관성에 대한 책임이 외부로 분산된다
	- `setShippingInfo`라는 것 자체에는 도메인 규칙에 대한 이해가 전혀 없다.

### 3.2.3 트랜잭션 범위

- 트랜잭션 범위는 좁을수록 좋다 → 넓으면 성능이 저하됨
- 한 애그리거트에서 다른 애그리거트를 수정하면 안된다
	- 애그리거트 간 독립성을 깨는 행위
	- 결과적으로 트랜잭션 범위가 넓어짐
	- 수정하고 싶다면 응용 계층에서 두 애그리거트를 수정하도록 해야한다.

## 3.4 ID를 이용한 애그리거트 참조

- 하나의 애그리거트에서 다른 애그리거트를 참조할 수 있다.

```java
public class Order{
	private Orderer orderer;
	...
}

public class Orderer{
	private Member member;
	private String name;
	...
}
public class Member{
	
}
```

- 문제점
	- 편리함의 오용
	- 성능문제
	- 확장성
- 편리함의 오용
	- 하나의 애그리거트에서 손쉽게 다른 애그리거트를 참조하므로 애그리거트 내에서 도메인 규칙을 구현한 메서드를 제공할 때 다른 애그리거트를 수정하는 실수 → 트랜잭션 범위가 커지고 책임도 분리가 안된다
- 성능문제
	- 표현 영역에 제공할때는 즉시로딩
	- 수정할때는 필요 없는 정보까지 가져올 필요가 없으므로 지연로딩 
	- 항상 고려해야한다.
- 확장성
	- 서비스 초기에는 단일 서버
	- 서비스가 커지면 도메인 단위로 트래픽을 쪼갤 수 있다.
		- 도메인 마다 사용하는 RDBMS가 다르고 심지어 NoSQL을 사용 → JPA로만 해결이 되지 않는다
- 해결책은 ID를 통해 애그리거트를 참조하자
- 같은 애그리거트라면 참조를 사용, 다른 애그리거트면 ID를 통해서 참조

### 3.4.1 ID를 이용한 참조와 조회  성능

- ID를 이용한 애그리거트 참조는 애그리거트간 지연로딩과 동일한 효과
- 지연로딩이 가지고 있는 N+1 문제

> [!faq]- N+1 문제?
> - N개의 데이터 조회시 N개 데이터를 가져오는 1번의 쿼리 + 각 데이터와 연관된 데이터를 읽어오는 N번의 쿼리를 N+1 문제라고 한다

- 별도 Dao를 만들어 조회 전용 쿼리를 만든다(JPQL로 각 애그리거트를 join)
- 애그리거트가 다른 저장소를 사용하는 경우 위 해결책으로도 안된다. (Join 사용 불가)
	- 조회 전용 저장소 또는 캐시를 사용해야한다.
	- 구현은 어려우나 대용량 트래픽을 처리할 수 있다는 장점이 있다.

## 3.6 애그리거트를 팩토리로 사용하기

- 특정 상점이 더이상 상품을 생성하지 못하는 상황
```java
public class RegisterProductService{
	public ProductId registerNewProduct(NewProductRequest req){
		Store store = storeRepository.findById(req.getStoreId());
		checkNull(store);
		if(store.isBlocked()){
			throw new StoreBlockedException();
		}
		ProductId id = productRepository.nextId();
		Product product = new Product(id,store.getId());
		return id;
	}
}
```

- store가 유효한지 판단 + 유효하다면 Product 생성은 논리적으로 하나의 도메인 로직인데 애플리케이션 서비스에 노출이 되었다.
- 도메인 서비스를 만들거나 팩토리 메서드를 사용할 수 있지만 애그리거트에 넣을 수도 있다.

```java
public class Store{
	public Product createProduct(ProductId newProductId){
	if(isBlocked()) throw new StoreBlockedException();
	return new Product(newProductId);
	} 
}
```
- 만약 하나의 애그리거트 속성을 다른 애그리거트 생성에 사용된다면 팩토리 메서드를 구현하는 것을 고려해 보자