<p align="center">
  <img src="https://github.com/devbelly/TIL/assets/67682840/0b619ae5-6e47-4736-8107-b4966eb7871d">
</p>

# 1. 도메인 모델 시작하기

## 1.1 도메인이란?

> [!info] 도메인이란?
> - 소프트웨어로 해결하고자 하는 문제영역을 의미한다.

^ded0ec

- 도메인은 하위 도메인으로 나뉠 수 있다.
	- 쇼핑몰이라는 큰 도메인은 결제, 정산, 배송, 할인 등 하위 도메인으로 나눌 수 있다.
- 하나의 도메인에서 모두 처리하기 보단 외부 시스템과 연계할 수도 있다.

## 1.2 도메인 전문가와 개발자와의 대화

- 각 도메인 전문가마다 자신의 경험치를 토대로 요구사항을 말한다.
	- 회계사는 엑셀에 있는 내용을 특정 방식으로 자동화
	- AS기사는 사용자에게 보낼 내용에 대한 템플릿 생성
- 요구사항은 첫단추와 같아 항상 자세히 분석해야한다.
	- 도메인 전문가와 개발자 사이에 많은 사람이 개입한다면 요구사항이 변질될 가능성이 높다.

## 1.3 도메인 모델

> [!info] 도메인 모델이란?
> - 도메인을 이해하기 위해 개념적으로 표현한 것.

- 도메인 모델을 표현할 때는 다양한 방법을 사용할 수 있다.
	- 객체 모델
	- 그래프
	- 다이어그램
- 도메인 모델을 구현하기 위한 물리 모델은 최대한 표현 방식을 따를 수 있다.
	- 객체 모델을 선택했다면 객체지향적인 언어를 선택
	- 수학적인 모델을 선택했다면 함수형 언어를 선택

## 1.4 도메인 모델 패턴

- 아키텍쳐에서 도메인 계층을 구현할 때 객체지향적으로 도메인을 설계하는 것을 도메인 모델 패턴이라고 한다.
- 도메인 계층에는 도메인의 핵심 규칙을 구현한다.
	- 주문 도메인의 핵심 규칙
		- 출고전에는 배송지를 변경할 수 있다.
		- 배송시작전이라면 주문을 취소할 수 있다.
		- etc
- 핵심규칙(예를 들어 배송지 변경)이 `Order.class`에 속하든 `OrderState.class`에 속하는지 상관없이 도메인 모델 내애 속해있으면…
	- 변경 시 다른 코드에 영향을 덜 준다.

> [!info] 도메인 모델?
> - 도메인을 개념적으로 표현할때 도메인 모델이라는 표현을 사용
> - 도메인 계층을 표현한 객체 모델을 언급할때도 도메인 모델이라는 표현을 사용

## 1.5 도메인 모델 도출

- 도메인을 구성하는 핵심요소, 규칙, 기능을 파악하는 것에서 출발한다.
	- 위 내용의 기초가 되는 것은 요구사항을 분석
- 한 상품을 한개 이상 주문할 수 있다 + 각 상품의 구매 가격 합은 상품 가격에 갯수를 곱한 값이다.
	- OrderLine에는 `Product`, `amount`, `price` 가 핵심 요소이다.
	- OrderLine에는 `getTotalAmount` 기능이 필요하다
- 최소 한 종류 이상의 상품을 주문해야한다 + 총 주문 금액은 각 상품의 구매 가격 하블 모두 더한 금액이다
	- Order과 OrderLine의 관계를 알 수 있다.
	- Order에는 `calculateTotalAmount` 기능이 필요하다

# 1.6 엔티티와 벨류

- 도출한 도메인 모델은 엔티티와 벨류로 구분할 수 있다.
- 엔티티의 가장 큰 특징은 식별자가 있다는 것이다.
	- 엔티티의 생성, 수정, 삭제까지 한번 생성된 식별자는 변하지 않는다.
	- 엔티티의 식별자가 같다면  동일한 엔티티로 판단. `equals()`와 `hashCode()`를 오버라이딩 할 수 있다.
- 식별자는 다음과 같은 방법으로 구할 수 있다.
	- DB에 맡기기
	- UUID
	- 특정 규칙에 따라 생성
- 벨류는 개념적으로 완전한 하나를 표현하기 위해 사용한다.
	- `ShippingInfo.class`에 `private String receiverName` 필드와 `private String receiverPhoneNumber` 필드가 존재
	- 이 필드들은 개념적으로 `수신인` 이라는 개념을 표현하는 중이므로 두 필드를 묶어 `Receiver`라는 클래스를 만들 수 있다.
		- `Receiver`는 벨류 타입이 된다.
	- 벨류 타입은 두개 이상의 필드를 사용해야만 하는 것은 아니다.
		- 개념적으로 의미를 잘 드러닐 수 있으면 하나의 필드를 사용할 수 있다.
	- 벨류 타입만의 메서드를 제공할 수 있다.
	- 벨류 타입의 값을 변경할 때는 새로운 객체를 리턴하는 방식을 사용한다.

		```java
		public class Money{
			private int price;
		
			public Money add(Money added){
				return new Money(this.price+added.price);
			}
		}
		```
		- 불변 객체로써 안전한 코드를 작성할 수 있게 된다.
		- Money가 가변객체라면 전달받은 파라미터(added)를 복사해서 사용해야한다.
		- Money가 불변 객체라면 복사할 필요 없이 바로 사용할 수 있다.

### 1.6.3 도메인 모델에 set 넣지 않기

- 프로그래밍을 하다보면 무분별하게 `get`과 `set`을 사용한다. ^1ec7c4
- 도메인 모델에 세터를 두면 단점이 생긴다!
	- 도메인 모델의 핵심 로직을 잃게 된다.
	- 도메인 모델 생성시 객체가 온전치 않은 상태로 존재할 수 있다.

> [!faq]- 도메인 모델의 핵심 로직을 잃게 된다?
> - `changeShippingInfo()`는 새로운 배송지로 변경한다는 의미를 담고 있지만 `setShippingInfo`는 단순하게 배송지를 설정하는 의미를 담는다.
> - `completePayment`는 결제 완료의 의미를 담지만 `setOrderStatus`는 단순히 상태 변경만을 나타낸다.
> - `completePayment`는 결제완료와 관련된 도메인 지식을 코드에 담는 것이 자연스럽다
> - `setOrderStatus`는 상태만 변경할지 해당 상태 변경에 따른 추가 로직이 필요할지 판단하기 어렵다. 즉 도메인 지식을 코드에 녹여내기 어렵다. 
> → `set`을 사용하면 도메인 지식을 코드에 녹여내기 어렵다.


## 1.7 도메인 용어와 유비쿼터스 언어

- 코드 작성 시 도메인 용어와 변수명을 최대한 일치시켜야한다.
	- 그렇지 않으면 용어 전환에 따른 비용이 발생
	- 예를 들어 개발자가 STEP1, STEP2, STEP3 와 같이 표현하면 각각이 무슨 의미인지 파악하기까지 시간이 걸린다.
- 각 도메인 전문가와 개발자는 시간이 지남에 따라 도메인에 대한 이해도가 높아진다.
	- 전문가들끼리 의사소통에 사용하는 언어를 유비쿼터스 언어라고 한다.

# 2장. 아키텍쳐 개요

## 2.1 네 개의 영역

- 표현, 응용, 도메인, 인프라스트럭쳐로 나눌 수 있다.
- 표현
	- 사용자에게 보여지는 영역을 담당한다.
	- 사용자 요청을 응용 영역이 필요한 데이터로 변환하거나 응용 영역의 결과를 사용자가 필요한 형태로 반환한다.
		- 객체와 json 변환 담당
- 응용
	- 사용자에게 필요한 기능을 구현. 구현 시 도메인 모델을 활용한다.
	- 코드
	```java
	public void OrderCancel(String orderId){
		Order order = findOrderById(orderId);
		if(order == null) threw new Exception():
		order.cancel();
	}
	```
	- 직접 로직을 수행하는 대신 도메인 모델에 로직 수행을 위임한다.
- 도메인
	- 도메인의 핵심 로직을 구현한다.
- 인프라스트럭쳐
	- 기술 구현에 대한 상세를 다룬다

## 2.2 계층 구조 아키텍쳐

- 표현 - 응용 - 도메인 - 인프라스트럭처를 계층 구조로 사용한다.
- 상위 계층은 하위 계층에 의존적이며 하위 계층은 상위 계층에 의존적이지 않다.
	- 엄격히 적용하면 상위 계층은 바로 아래 있는 하위 계층에만 의존해야하지만 구현의 편리함을 위해 포기할 수도 있다.
- 계층 구조는 직관적이지만 표현, 응용, 도메인 영역이 인프라스트럭처 계층에 매우 의존적인 형태를 띠게 된다.
- 예를 들어 `OrderDiscountService`가 인프라스트럭처 계층의 `DroolsRuleEngine`에 의존하고 있다 해보자.
	- 문제점
		- `OrderDiscountService`를 테스트하기 위해서는 `DroolsRuleEngine`이 존재해야한다.
		- `OrderDiscountService`에서 코드를 변경하기 어렵다.
			- 실제로 `DroolsRuleEngine`이 제공하는 객체를 사용하지 않더라도 로직 자체가 간접적으로 의존하게 되어있다. (전달하는 파라미터, 결과값을 위해 사용하는 객체 등등)
	- 해결책
		- DIP를 사용하자

## 2.3 DIP

- `OrderDiscoutService`는 아래 두 하위 모듈을 통해 서비스를 제공한다
	- 고객 정보를 구해온 후
	- 룰을 이용해서 할인 금액을 구한다.
- `OrderDiscountService` 입장에선 할인 금액을 구하는 것이 중요하지 해당 로직을 구현할 때 java로 구현한지 Drools로 구현한지는 관심 밖이다.
	- 추상화된 인터페이스를 제공함으로써 상위모듈이 하위 모듈에 의존하는 형태를 분리해내자.
	- 코드
	```java
	interface RuleDiscounter{
		Money applyRules(Customer customer, List<OrderLine> orderLines);
	}
	```
- 하위모듈인 `DroolsRuleEngine`은 `RuleDiscounter`를 구현함으로써 하위 모듈이 상위모듈에 의존하게 된다. → DIP 적용
	- 구현 객체를 변경하더라도 상위 모듈은 변경될 필요가 없다.
	- 테스트시 실제 클래스가 존재할 필요 없이 Mock를 사용하면 된다.

## 2.4 도메인 영역의 주요 구성요소

- 엔티티와 벨류
	- 엔티티는 식별자로 구분되어 하나의 라이프사이클을 가진다
	- 벨류는 개념적으로 하나로 표현하기 위해 사용하는 객체
	- DBMS 객체 vs 도메인 엔티티 객체
		- 도메인 객체는 데이터의 저장뿐만 아니라 기능 구현까지 제공한다.
		- 기능을 제공함으로써 객체가 허용된 범위 밖에서 변경되는 것을 방지할 수 있다.
		- 벨류 객체를 온전하게 사용할 수 있다.
			- DBMS에서는 벨류 객체를 하나의 엔티티로 저장하거나 파라미터로 늘어놓는 형태.
			- 도메인 엔티티에서는 벨류 객체를 온전하게 사용함으로써 엔티티에 대한 이해도가 증가
- 애그리거트
	- 개발을 진행하다보면 엔티티와 벨류가 많이짐에 따라 모델 또한 커진다
	- 개발자는 큰 개념에 집중하기 보다 개별 엔티티에 집중하게 되어 전체 구조 제대로 파악하지 못할 수 있다.
	- 관련 있는 엔티티와 벨류를 상위 개념으로 묶은 것이 애그리거트이다.
	- 주문 애그리거트에는 주문 엔티티, 주문자 벨류, 주문목록 엔티티 등 여러 엔티티와 벨류들이 모일 수 있다.
	- 애그리거트는 루트 엔티티를 가진다
		- 루트 엔티티는 군집을 관리한다.
	- 애그리거트를 사용하는 코드는 애그리거트 루트가 제공하는 기능을 사용하고 다른 엔티티에 대한 접근을 제어함으로써 에그리거트 단위로 캡슐화 할 수 있다.

## 2.6 인프라스트럭처 개요

- 인프라스트럭처는 표현, 응용, 도메인 영역을 지원한다.
- DIP를 실현하여 변경이 용이함이나 테스트의 편리함을 챙길 수도 있지만 무조건 인프라스트럭처에 의존을 안하는게 옳지는 않다.
	- 트랜잭션처리를 스프링에서 제공하는 `@Transactional` 을 사용
	- 도메인 영역 클래스에 `@Entity`나 `@Table`을 사용
- DIP 장점만큼 구현의 편리함 또한 중요하므로 경중을 잘 따져가며 사용하자

> [!info] Domain Service vs Application Service
> - [# Domain services vs Application services 한글](https://americanopeople.tistory.com/372)
> - [# Domain services vs Application services](https://enterprisecraftsmanship.com/posts/domain-vs-application-services/)
> - [# What is domain logic?](https://enterprisecraftsmanship.com/posts/what-is-domain-logic/)
> 

- 도메인 서비스?
	- 특정 엔티티에 속하지 않는 도메인 로직을 제공한다.
	- 결제 로직을 살펴보면 상품, 주문, 할인, 주문자 등 여러 애그리거트의 조합으로 이루어져 있다.
	- 결제 로직을 `Order` 애그리거트에 억지로 넣으려고 하면 의존성이 증가하게 된다.
	- 도메인 기능을 별도 서비스로 제공 → 이를 도메인 서비스라고 한다.

- 도메인 서비스를 도입해야하는 경우?
	- 외부 서비스의 도움없이 도메인 불변성을 유지할 수 없는 경우
	- 예를 들어 ATM 엔티티는 외부 서비스인 `paymentGateWay`의 도움없이 도메인 불변성을 유지하기 어렵다
	- 이럴 때 도메인 서비스를 사용하면 도움이 된다

- 도메인 서비스 vs 애플리케이션 서비스
	- 도메인과 벨류들 위에서 동작하는 *상태없는* 클래스
	- 가장 큰 차이점은 도메인 서비스를 도메인 로직을 담고 있지만 애플리케이션 서비스는 도메인 로직이 없다

- 도메인 로직?
	- 도메인 로직을  잘 분리해야하는 이유?
		- 다른 영역(UI, persistence)으로 부터 잘 분리된 도메인 로직을 통해 도메인 파악이 매우 용이해진다.
	- 도메인 로직은 의사결정과 관련이 있다.

**예시1**

```csharp
private void TakeMoney(decimal amount)
{
    string error = _atm.CanTakeMoney(amount);
    if (error != string.Empty)
    {
        NotifyClient(error);
        return ;
    }
 
    decimal amountWithCommission = _atm.CaluculateAmountWithCommission(amount);
    _paymentGateway.ChargePayment(amountWithCommission);
    _atm.TakeMoney(amount);
    _repository.Save(_atm);
 
    NotifyClient("You have taken " + amount.ToString("C2"));
}
```

- `TakeMoney`는 애플리케이션 서비스 로직
- 돈을 인출할 수 있는지, 계산된 수수료는 얼마인지에 대한 결정은 `atm`이 내린다.
	- 핵심 로직은 도메인 클래스인 ATM이 판단한다
- `TakeMoney`는 도메인 모델이 내린 결정을 오케스트레이션 + side effect를 만든다 ^b2dd53
	- data store에 저장하기
	- user에게 보여주기
	- 3rd-party 서비스에 전달하기

- Injecting a domain service into an entity
	- 위 링크의 저자는 도메인 서비스를 `pure`한 서비스와 `impure`한 서비스로 나눴다.
	- `pure`한 서비스는 한 도메인에 닫혀있지만(해당 도메인의 엔티티 + 값객체)
	- `impure`한 서비스는 다른 도메인까지 같이 사용한다. 즉 두개를 구분하는 것을 권장한다.

# 3장. 애그리거트

## 3.1 애그리거트

- 엔티티가 복잡해지면 큰 범위에서 파악하기보단 개별 엔티티간 관계를 파악하기에 복잡하다
- 큰 단위. 애그리거트로 묶어서 보면 프로젝트 파악이 쉬워진다 → 수정이 용이해진다
- 애그리거트는 관련 객체들끼리 라이프 사이클을 거의 공유한다.
- 애그리거트를 나누는 기준은 도메인 규칙과 요구사항이 될 수 있다.
	- 도메인 규칙에 따라 주문할 상품 갯수, 배송지 정보, 주문자 정보는 함께 생성 → 하나의 애그리거트
	- 사용자 요구사항에 따라 주문 상품의 갯수와 배송지 정보를 함께 변경하기도 한다 → 하나의 애그리거트
- A가 B를 포함한다 말 자체로는 애그리거트를 나누기 어렵다
	- Order가 ShippingInfo와 Orderer를 포함한다는 개념으로는 맞는 것 같으나
	- Product와 Review는 함께 생성되지도 않고 수정되지도 않는다.
- 다수의 애그리거트가 하나의 엔티티를 갖는 경우가 많았다!!

## 3.2 애그리거트 루트

- 애그리거트 단위로 일관성이 유지되도록 해야한다.
	- OrderLine은 갯수와 가격을 담고 있는데 갯수가 변경되면 Order 엔티티의 `totalAmount` 또한 변경되어야 한다.
- 일관성을 책임지는 엔티티 → 애그리거트 루트
- 애그리거트 루트는 도메인 규칙을 적용한 메서드를 제공해야한다
	- `changeShippingInfo` : 출고전에 배송지 변경이 가능하다
- 애그리거트 루트가 아닌 외부에서 애그리거트를 변경해선 안된다.
	```java
	// 아래처럼 작성하면 안된다!
	ShippingInfo si = order.getShippingInfo();
	si.setAddress(newAddress);
	```
	- 애그리거트 일관성을 유지할 책임이 애플리케이션이나 프레젠테이션으로 옮겨지게 된다
	- 결과적으로 중복된 도메인 로직을 작성할 확률이 높아진다.
- 중복된 도메인 로직을 피하기 위해선 다음 규칙을 지키자
	- 공개된 세터 금지
	- 불변 벨류 사용
- 공개된 세터
	- 애그리거트 일관성에 대한 책임이 외부로 분산된다
	- `setShippingInfo`라는 것 자체에는 도메인 규칙에 대한 이해가 전혀 없다.

### 3.2.3 트랜잭션 범위

- 트랜잭션 범위는 좁을수록 좋다 → 넓으면 성능이 저하됨
- 한 애그리거트에서 다른 애그리거트를 수정하면 안된다
	- 애그리거트 간 독립성을 깨는 행위
	- 결과적으로 트랜잭션 범위가 넓어짐
	- 수정하고 싶다면 응용 계층에서 두 애그리거트를 수정하도록 해야한다.

## 3.4 ID를 이용한 애그리거트 참조

- 하나의 애그리거트에서 다른 애그리거트를 참조할 수 있다.

```java
public class Order{
	private Orderer orderer;
	...
}

public class Orderer{
	private Member member;
	private String name;
	...
}
public class Member{
	
}
```

- 문제점
	- 편리함의 오용
	- 성능문제
	- 확장성
- 편리함의 오용
	- 하나의 애그리거트에서 손쉽게 다른 애그리거트를 참조하므로 애그리거트 내에서 도메인 규칙을 구현한 메서드를 제공할 때 다른 애그리거트를 수정하는 실수 → 트랜잭션 범위가 커지고 책임도 분리가 안된다
- 성능문제
	- 표현 영역에 제공할때는 즉시로딩
	- 수정할때는 필요 없는 정보까지 가져올 필요가 없으므로 지연로딩 
	- 항상 고려해야한다.
- 확장성
	- 서비스 초기에는 단일 서버
	- 서비스가 커지면 도메인 단위로 트래픽을 쪼갤 수 있다.
		- 도메인 마다 사용하는 RDBMS가 다르고 심지어 NoSQL을 사용 → JPA로만 해결이 되지 않는다
- 해결책은 ID를 통해 애그리거트를 참조하자
- 같은 애그리거트라면 참조를 사용, 다른 애그리거트면 ID를 통해서 참조

### 3.4.1 ID를 이용한 참조와 조회  성능

- ID를 이용한 애그리거트 참조는 애그리거트간 지연로딩과 동일한 효과
- 지연로딩이 가지고 있는 N+1 문제

> [!faq]- N+1 문제?
> - N개의 데이터 조회시 N개 데이터를 가져오는 1번의 쿼리 + 각 데이터와 연관된 데이터를 읽어오는 N번의 쿼리를 N+1 문제라고 한다

- 별도 Dao를 만들어 조회 전용 쿼리를 만든다(JPQL로 각 애그리거트를 join)
- 애그리거트가 다른 저장소를 사용하는 경우 위 해결책으로도 안된다. (Join 사용 불가)
	- 조회 전용 저장소 또는 캐시를 사용해야한다.
	- 구현은 어려우나 대용량 트래픽을 처리할 수 있다는 장점이 있다.

## 3.6 애그리거트를 팩토리로 사용하기

- 특정 상점이 더이상 상품을 생성하지 못하는 상황
```java
public class RegisterProductService{
	public ProductId registerNewProduct(NewProductRequest req){
		Store store = storeRepository.findById(req.getStoreId());
		checkNull(store);
		if(store.isBlocked()){
			throw new StoreBlockedException();
		}
		ProductId id = productRepository.nextId();
		Product product = new Product(id,store.getId());
		return id;
	}
}
```

- store가 유효한지 판단 + 유효하다면 Product 생성은 논리적으로 하나의 도메인 로직인데 애플리케이션 서비스에 노출이 되었다.
- 도메인 서비스를 만들거나 팩토리 메서드를 사용할 수 있지만 애그리거트에 넣을 수도 있다.

```java
public class Store{
	public Product createProduct(ProductId newProductId){
	if(isBlocked()) throw new StoreBlockedException();
	return new Product(newProductId);
	} 
}
```
- 만약 하나의 애그리거트 속성을 다른 애그리거트 생성에 사용된다면 팩토리 메서드를 구현하는 것을 고려해 보자

# 4. 리포지터리와 모델 구현

## 4.3 매핑구현

- 애그리거트 루트는 엔티티 이므로 `@Entity`를 사용한다
- 벨류는 `@Embeddable`을 사용한다
- 벨류 프로퍼티는 `@Embedded`를 사용한다
- 보통 하나의 엔티티와 벨류는 한 테이블에 담을 수 있다.

### 4.3.3 필드 접근 방식 사용

- JPA가 객체 매핑을 위해서 필드 접근 방식과 메서드 접근 방식 둘 중 하나를 사용할 수 있다.
- 메서드 접근 방식
	- 공개된 getter/setter를 통해 매핑을 한다
	- 공개된 세터의 문제
		- 도메인 의도를 파괴하기 쉽다. `setState`는 `cancel`보다 의도 파악이 어렵다.
		- 외부에서 세터에 접근해 객체에 대한 캡슐화가 깨진다
		- `@Access(AccessType.PROPERTY)`
- 필드 접근 방식
	- 불필요한 getter/setter 선언을 막을 수 있다.
	- `@Access(AccessType.FIELD)`
	- `private`으로 선언되어 있어도 리플렉션을 통해 접근한다.

### 4.3.4 AttributeConverter를 이용한 벨류 매핑 처리

- 단일 프로퍼티는 하나의 데이터베이스 칼럼에 매핑할 수 있다.
- 경우에 따라 두 개 이상의 프로퍼티를 가진 벨류를 하나의 데이터베이스 칼럼에 매핑해야할 필요가 있을 수 있다.
	- `private String unit` + `private int value` → 1000mm
- `@Embeddable`로만은 어려우므로 AttributeConverter를 사용하자!

### 4.3.8 별도 테이블에 저장하는 벨류 매핑

- 애그리거트는 하나의 엔티티에 여러 벨류로 이루어진 경우가 많다.
	- 착각1) 테이블에 저장한다고 해서 엔티티가 아니다
		- `OrderLine`은 테이블에 저장했지만 엔티티가 아니라 벨류
	- 착각2) 엔티티로 판단되었다면 라이프 사이클을 같이하는지 확인해야한다.
		- `Product`와 `Review`는 수정 주체도 다르고 서로 독립적이므로 서로 다른 애그리거트!
- 엔티티와 벨류를 어떻게 구분해야할까?
	- 식별자의 유무로 판단하자
	- 단! 데이터베이스에 물리적으로 존재하는 ID와 애그리거트의 식별자를 구별해야한다.
	- `ARTICLE` - `ARTICLE_CONTENT` 관계에서 `ARTICLE_CONTENT`에 ID가 있어도 이는 단독적으로 컨텐츠를 구하려는 것이 아닌 ARTICLE과 연관을 짓기위한 ID. 
- `@Embeddable` + `@SecondaryTable`을 사용해 별도 테이블에 벨류를 저장할 수 있다.
- `@SecondaryTable`을 사용하면 아래 코드 실행 시 자동으로 벨류 테이블과 JOIN을 해서 정보를 가져온다

```java
Article article = em.find(Article.class,1L);
```

- 게시글 목록을 불러올 때 게시글 내용을 불러오는 것은 원하는 바가 아니다.
	- 해결책1
		- `Article_Content` 벨류를 엔티티로 만들어 지연로딩
		- 벨류를 엔티티로 만드는 것은 좋은 설계가 아니다.
	- 해결책2
		- 조회 전용 쿼리 생성

### 4.3.9 벨류 컬렉션을 @Entity로 매핑하기

- 팀 표준 또는 구현 기술의 한계 때문에 벨류를 엔티티로 사용해야할 수도 있다.
- Image의 종류로 Internal Image와 External Image가 존재.
	- 하지만 JPA에서는 `@Embeddable` 타입의 상속 매핑을 지원하지 않는다 → `@Entity`를 이용해서 상속관계를 처리
	- `Image` 추상 클래스에는 `@Inheritance`, `@DiscriminatorColumn` 명시
- `Product`는 여러개의 `Image` 클래스를 가질 수 있으므로 `OneToMany`를 사용
	- `Image`가 Entity로 적혀있긴 하지만 실제로는 Product와 라이프사이클을 공유하므로 `orphanRemoval=true` 옵션을 적용해서 라이프사이클을 공유한다.
- 주의사항
	- 컬렉션의 `clear` 메서드를 호출할 때 담고있는 대상이 `Entity`라면 
		- 한번의 select 쿼리 + 각 객체마다 delete 쿼리 호출
	- 컬렉션의 clear 메서드를 호출할 때 담고있는 대상이 `Embeddable`
		- 단 한번의 delete 쿼리
	- `clear`가 성능 문제를 일으킨다면 다형성을 포기해야할 수도 있다.

## 4.4 애그리거트 로딩 전략

- 애그리거트 루트를 로딩하면 애그리거트에 속한 객체들은 완전한 상태여야한다
- `FetchType.EAGER`을 사용하면 적절할까?
	 - 카테시안 곱 문제가 발생할 수 있다.
	 - `Product`의 속성으로 `Images`와 `Options`가 존재하는 상황에서 기본전략인 `LAZY` 대신 `EAGER`을 사용하면 카테시안 곱 문제 발생!
		 - N+1 문제와는 다르게 실행되는 쿼리는 한줄이지만 결과행이 카테시안 곱
		 - `Images`가 15개, `Options`가 20개면 하나의 Product에 대해 결과값은 300개 발생(실제로는 1+15+20 개 필요)
- 애그리거트 루트 로딩 시 왜 객체들은 완전한 상태여야할까?
	- 1. 엔티티 수정 시 객체의 상태가 완전해야하므로
	- 2. 엔티티를 표현 영역에 줄 때 객체의 상태가 완전해야하므로 → 조회 전용 기능 + 모델로 해결가능

# 5. 스프링 데이터 JPA를 이용한 조회 기능

## 5.1 CQRS

- 명령 모델과 조회 모델을 분리한 패턴

## 5.2 Specification

- 애그리거트가 특정 조건을 만족하는지 확인하는 인터페이스

## 5.3 스프링 데이터 JPA를 이용한 스펙구현

```java
public interface Specification<T> extends Serializable {  
  
   long serialVersionUID = 1L;  
  
	// and or not 생략
   Predicate toPredicate(Root<T> root, CriteriaQuery<?> query, CriteriaBuilder criteriaBuilder);  
}
```

- T는 JPA 엔티티를 의미한다.
- `toPredicate`는 JPA Criteria API에서 조건을 표현하는 `Predicate`를 리턴한다
- `Specification`은 함수형 인터페이스이므로 람다를 이용해서 구현해도 된다.

> [!faq]- 함수형 인터페이스?
> - 단 하나의 추상 메서드를 같은 인터페이스를 의미한다.
> - default가 메서드가 여러개 있어도 상관없다.

## 5.4 리포지터리 / DAO에서 스펙 사용하기

- `findAll` 메서드 정의 후 파라미터로 `Spec`을 받으면 된다.

```java
public interface OrderSummaryDao extends Repository<OrderSummary,String>{
	List<OrderSummary> findAll(Specification<OrderSummary> spec);
}
```

- 클라이언트에서는 스펙을 생성한 후 해당 메서드를 호출하자

```java
Specification<OrderSummary> spec = new OrdererIdSpec("user1");
orederSummaryDao.findAll(spec);
```

## 5.6 정렬 지정하기

- 스프링 데이터 JPA에서 정렬을 지정하는 방법
	- 메서드명 + `orderBy`
	- `Sort` 객체 사용
- 메서드명 + `orderBy`
	- 간단하다
	- 조건이 두개이상인 경우 메서드명이 길어지는 단점이 있다. `findAllOrderByNumberDescUserIdAsc`
	- 정렬 조건을 유연하게 바꾸기 어렵다
- `Sort`객체 사용
	- `Sort.by("number").ascending()` 

# 5.7 페이징 처리하기

- `Repository` 인터페이스안 메서드에 `Pageable` 파라미터를 추가하자

```java
public interface ~ {
	List<MemberData> findByNameLike(String name, Pageable pageable)
}
```

- `Pageable`은 인터페이스. 클라이언트에서 호출할 때 `PageRequest` 클래스를 사용한다.

```java
PageRequest req = PageRequest.of(1,10);
List<MemberData> result = memberDataDao.findByNameLike("사용자%", req);
```

	- `PageRequest.of(1,10)`
		- 1 : 두 번째 페이지를 의미한다.
		- 10 : 페이지당 불러올 데이터 수를 의미한다.

- `PageRequest` 객체는 `Sort` 객체를 파라미터로 넘겨 생성할 수도 있다.

```java
PageRequest req = PageRequest.of(1,10,Sort.by("name").descending());
```

- 인터페이스에서 리턴타입을 `List<MemberData>` 대신 `Page<MemberData>`를 사용하면 추가적으로 `Count` 쿼리가 발생한다.

	- 단, Count 쿼리가 **필요한** 경우에만 발생한다. 데이터 수가 적으면 Count 쿼리를 실행하지 않음!

# 6장. 응용 서비스와 표현 영역

## 6.2 응용 서비스의 역할

- 표현 영역과 도메인 영역을 연결해주는 역할을 한다.
- 도메인 객체의 로직을 조합하는 역할을 한다. [[#^b2dd53 | 참고]]
- 응용 서비스는 비교적 간단하다. 복잡하다면 도메인 로직을 응용 서비스에서 구현하고 있을 수 있다.
	- 코드의 중복, 유지보수에 문제가 생기므로 도메인 로직을 응용 서비스에서 구현하지 말자!
- 응용 서비스는 트랜잭션을 관리한다.
- 접근 권한 및 이벤트 처리는 추후 알아보자

### 6.2.1 도메인 로직 넣지 않기

- 응용 계층에서 도메인 로직을 넣는 경우가 있다.
- 문제점
	- 응집도가 떨어진다.
		- 도메인 객체와 이를 수정하는 도메인 로직이 도메인 계층에 속하지 않게 된다.
		- 도메인 로직을 파악하기 위해 여러 계층을 확인해야한다.
	- 코드 중복이 발생한다.
→ 결국 수정이 어려워지는 문제가 발생한다.

## 6.3 응용 서비스의 구현

- 응용 계층은 표현 계층와 도메인 계층을 이어주는 역할을 한다.
- 디자인 패턴으로는 Facade가 하는 역할과 동일하다.

### 6.3.1 응용 서비스의 크기

- 두가지 방법
	- 하나의 클래스에 모든 도메인 로직 구현
	- 서로 관련 있는 서비스끼리 나눠서 구현
- 하나의 클래스에 모든 도메인 로직 구현
	- 중복되는 코드를 `private` 메서드로 묶어서 사용할 수 있다 → 코드 중복 해결
	- 하나의 클래스가 커지는 문제 발생 
		- 필드가 어디서 사용되는지 파악해야한다 
		- 응용 계층에 기능이 추가되면 클래스를 분리해야함에도 습관적으로 하나의 클래스에 밀어넣는다.
- 서로 관련 있는 서비스끼리 나눠서 구현
	- 각 서비스마다 중복되는 코드가 발생 → 공통으로 사용하는 로직을 묶어 Helper 클래스를 만들어 사용
	- 각 클래스마다 1~3개 메서드 사용 권장
	- 응집도가 올라가며 필요한 객체만 주입받아 사용

### 6.3.2 응용 서비스의 인터페이스와 클래스

- 인터페이스를 구현해야할까?
- 인터페이스 사용의 장점
	- 런타임에 구현체가 바뀌는 경우
	- 인터페이스에 대한 구현체가 여러개인 경우
	 → 응용 서비스는 이 두 경우가 거의 해당하지 않는다.
- TDD 개발 → 표현 영역부터 개발을 시작하며 응용 계층에 대한 구현이 되어있지 않아 자연스레 인터페이스 사용
- 응용 & 인프라 개발 → 클래스 구현이 되어있다. 테스트 시에도 Mockito를 사용하면 간단하게 해결! 굳이 인터페이스가 필요 없다.

### 6.3.3 메서드 파라미터와 값 리턴

- 응용 계층이 리턴한 것 중 필요한 정보만 표현계층에 리턴한다.
- 애그리거트 자체를 리턴?
	- 구현은 편리함
	- 도메인 로직을 응용 계층뿐만 아니라 표현 계층에서도 도메인 로직에 접근할 수 있다.
	- 표현 계층에서는 도메인 로직을 사용하지 말자는 규칙을 정할수도 있지만 더 확실하게 필요한 정보만 리턴하는 것이 응집도를 높일 수 있다.

### 6.3.4 표현 영역에 의존하지 않기

- 서비스 계층에서 사용하는 파라미터, 리턴 타입은 표현영역에 의존해선 안된다!
	- HttpSession, HttpServletRequest …

# 7장. 도메인 서비스

## 7.1 여러 애그리거트가 필요한 기능

- 할인된 결제 금액을 계산하는 로직에 대한 책임은 단 하나의 애그리거트가 지기 어렵다.
- 억지로 하나의 도메인에 넣으면 의존성이 증가하고 책임 분리가 제대로 안된다

## 7.2 도메인 서비스

- 위 상황에서 도메인 서비스를 쓰기 적합하다
- 도메인 서비스를 사용하기 좋은 경우
	- 여러 애그리거트가 섞여있는 로직
	- 외부 서비스를 이용하는 로직(결제 API 호출)
- 애그리거트 및 벨류와 도메인 서비스의 가장 큰 차이점은 “상태”를 갖지 않는다
- 도메인 서비스의 사용 주체는 애그리거트 또는 응용 서비스 (응용 서비스만 사용하는 줄 알았다)
- 애그리거트에서 도메인 서비스 객체를 파라미터로 넘겨받아 사용할 수도 있고
- 도메인 서비스 객체에서 애그리거트들을 넘겨받아 응용 서비스에서 조합해 사용할 수도 있다.
- 다른 도메인 구성 요소와 마찬가지로 도메인 패키지에 위치.
	- 만약 외부 서비스와 연동(룰 엔진)을 한다면 인터페이스와 구현클래스를 분리
	- 인터페이스는 도메인 패키지에 구현 클래스는 인프라에 위치시킨다

# 8장. 애그리거트 트랜잭션 관리

# 8.1 애그리거트와 트랜잭션

- 운영자 쓰레드와 유저 쓰레드에서 논리적으로 동일한 애그리거트에 접근, 하지만 실제 생성되는 객체는 다르다.
- 동시에 애그리거트를 얻어 수정을 하면 애그리거트 일관성이 깨지는 상황이 발생한다.
	- 운영자는 배송 상태를 시작으로 변경
	- 유저는 배송지를 다른 곳으로 변경
- DBMS에서 제공하는 트랜잭션뿐만 아니라 애그리거트에서도 일관성을 유지하기 위한 방법이 필요하다.

## 8.2 선점잠금

- DB에서 제공하는 Row-level-lock을 이용해서 구현한다
- 1번 쓰레드가 애그리거트를 얻으면 2번 쓰레드는 1번 쓰레드가 커밋하기 전까지 대기한다.
- 선점잠금시 deadlock 상황에 빠질 수 있으므로 주의해야한다.
	- 스프링에서는 queryHint를 파라미터로 넘겨서 최대 대기 시간을 지정한다
	- 스프링 Data jpa에서는 `@QueryHint` 어노테이션을 사용할 수 있다.

### 8.3.1 강제 버전 증가

- 애그리거트에서 루트 엔티티말고 다른 벨류나 엔티티에 변화가 생긴다면?
	- 루트 엔티티의 버전은 변경되지 않는다.
	- 하지만 이는 논리적으로 문제가 생김!!
- FORCE_INCREMENT옵션을 사용해서 트랜잭션 종료시 버전값을 강제로 증가시키자

# 9장. 도메인 모델과 바운디드 컨텍스트

# 9.1 도메인 모델과 경계

- 같은 상품이라도 각 도메인 마다 가르키는 바가 다르다.
- 논리적으로 같아 보여도 각 도메인마다 부르는 명칭이 다르다
- 도메인 설계 시 하나의 모델로 여러 하위 도메인을 표현하려고 하는데
	- 이는 제대로 표현이 안될 뿐더러
	- 각 하위도메인의 요구사항 변화를 제대로 반영하기도 어렵다.
- 모델은 자신의 컨텍스트에서 완전한 의미를 갖는다 → DDD에서는 이를 바운디드 컨텍스트라고 부른다.

## 9.2 바운디드 컨텍스트

- 해결하고자 하는 영역
- 사용하는 용어에 따라 바운디드 컨텍스트를 나눌 수 있다.
	- 카탈로그의 상품 vs 재고의 상품은 서로 다르다
- 하위 도메인과 바운디드 컨텍스트는 일대일 대응하지 않는다.
	- 팀 단위로 바운디드 컨텍스트를 나눌 수 있다
- 하나의 프로젝트에서 하위 도메인 모델이 여럿이면
	- 물리적인 바운디드 컨텍스트는 하나 → 하위 도메인에서 사용하는 모델을 단일 모델로 일치시키려는 욕구가 생긴다 (카탈로그의 상품과 재고의 상품을 일치시켜버린다.)
	- 패키지를 통해 논리적인 바운디드 컨텍스트를 나눠서 하위 도메인 마다 올바른 모델을 갖도록 한다.
- 바운디드 컨텍스트를 올바르게 나눈 결과
	- 카탈로그의 상품은 카테고리가 필요하지만 재고에서 상품은 카테고리가 필요하진 않다.
	- 주문에서 주문자는 벨류로 관리하지만 Member 도메인에서는 애그리거트 루트로써 역할을 한다

## 9.3 바운디드 컨텍스트 구현

- 바운디드 컨텍스트는 도메인 계층만 의미하지 않는다
- 바운디드 컨텍스트마다 각기 다른 아키텍쳐를 사용할 수 있다.
	- 복잡한 바운디드 컨텍스트 → DDD
	- 단순한 바운디드 컨텍스트 → 서비스-DAO 구조
- 하나의 바운디드 컨텍스트 안에 두 개의 아키텍쳐를 조합할 수도 있다 → CQRS

## 9.4 바운디드 컨텍스트 통합

- 카탈로그 도메인에서 추천 기능을 도입
- 카탈로그 컨텍스트와 추천 컨텍스트가 통합될 필요성이 생긴다.
- 카탈로그에서 사용하는 도메인 모델과 추천에서 사용하는 도메인 모델이 다르다
	- 직접적으로 인프라 영역에 두 모델의 변환을 처리해주는 코드를 구현할 수 있다.
	- 간접적으로 메세징 큐를 이용해 통합할 수도 있다.

## 9.5 바운디드 컨텍스트 간 관계

- 바운디드 컨텍스트 통합
	- REST API 방식을 사용 → 상류 바운디드 컨텍스트와 하류 바운디드 컨텍스트로 나눌 수 있다.
		- 하나의 상류 바운디드 컨텍스트 +다수의 하류 바운디드 컨텍스트라면 하류 바운디드 컨텍스트이 요구사항을 통합하여 상류 바운디드 컨텍스트에서 하나의 API를 제공할 수도 있다.
		- 대표적인 예시가 검색 상류 바운디드 컨텍스트
		- 상류 도메인 모델이 하류 도메인 모델을 침범하지 않도록 완충해야한다 → 안티코럽션 계층이 필요
		- 두 바운디드 컨텍스트에서 동일한 모델을 사용하는 경우도 있다 → 이를 공유 커널이라고 함
- 바운디드 컨텍스트를 수동으로 통합
	- 나쁘지는 않으나 서비스가 커지면 수동으로 통합하는 것에 한계가 올 수 있다.

# 10장. 이벤트

## 10.1 시스템 간 강결합 문제

- 환불을 주문 도메인에서 구현하는 상황
	- 방법1) 주문도메인에서 환불서비스를 파라미터로 받아 처리
	- 방법2) 응용 서비스 계층에서 처리
- 문제점
	- 트랜잭션
		- 외부 결제에 의존하는 환불서비스
		- 외부 시스템이 다운됐을 때, 롤백 or 커밋?
			- 롤백이 옳다고 생각할 수도 있지만 상태만 취소로 바꾸고 나중에 환불이 처리되도록 할 수도 있다.
	- 성능
		- 외부 서비스가 느려지면 환불 서비스도 느려질 수 밖에 없다.
	- 책임분리
		- 방법1 처럼 구현 시 주문 도메인에 주문 로직뿐만 아니라 결제 관련 로직도 섞인다.
- 해결책
	- 이벤트 + 비동기로 처리하자

## 10.2 이벤트 개요

- 이벤트 == 과거에 일어난 사건
- 이벤트의 발생은 상태 변경을 의미한다.
- 이벤트의 구성요소
	- 이벤트
		- 이벤트는 종류, 시간, 데이터 등으로 이루어져 있다.
		- 종류는 클래스 명. `ShippingInfoChangedEvent`
			- `Changed`와 같이 과거 시제를 사용한다.
	- 이벤트의 생성 주체
		- 도메인의 구성요소들이 주를 이룬다. ex) 도메인, 벨류, 서비스
	- 이벤트 퍼블리셔
		- 이벤트의 생성 주체와 이벤트 핸들러를 이어주는 역할을 한다.
		- 생성 주체가 이벤트를 퍼블리셔에 전달, 퍼블리셔는 해당 이벤트를 처리할 수 있는 핸들러에게 전달
	- 이벤트 핸들러
		- 이벤트를 받아서 처리한다.
- 이벤트 사용처
	- 후처리가 필요한 경우
	- 데이터 동기화
- 이벤트 장점
	- 도메인 로직의 분리가 가능하다
	- 기능확장에 유리하다

